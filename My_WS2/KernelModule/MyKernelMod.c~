#include <linux/module.h>  /* Needed by all modules */
#include <linux/kernel.h>  /* Needed for KERN_ALERT */
#include <linux/netfilter.h> 
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/compiler.h>
#include <net/tcp.h>
#include <linux/namei.h>
#include <linux/proc_fs.h> 
#include <asm/uaccess.h>
#include <linux/list.h>
#include "entry.h"

MODULE_AUTHOR ("Eike Ritter <E.Ritter@cs.bham.ac.uk>");
MODULE_DESCRIPTION ("Extensions to the firewall") ;
MODULE_LICENSE("GPL");


#define BUFFERSIZE 10

#define PROC_ENTRY_FILENAME "kernelRead"


/* make IP4-addresses readable */

#define NIPQUAD(addr) \
        ((unsigned char *)&addr)[0], \
        ((unsigned char *)&addr)[1], \
        ((unsigned char *)&addr)[2], \
        ((unsigned char *)&addr)[3]


struct nf_hook_ops *reg;
int counter = 0; /* number of entries to be transferred in total */

static struct proc_dir_entry *Our_Proc_File;

const struct file_operations File_Ops_4_Our_Proc_File = {
    .owner = THIS_MODULE,
    .read  = kernelRead,
    .open  = procfs_open,
    .release = procfs_close,
};

EXPORT_SYMBOL (FirewallExtensionHook);

static struct nf_hook_ops firewallExtension_ops = {
	.hook    = FirewallExtensionHook,
	.owner   = THIS_MODULE,
	.pf      = PF_INET,
	.priority = NF_IP_PRI_FIRST,
	.hooknum = NF_INET_LOCAL_OUT
};

/* Firewall Extension Module */
unsigned int FirewallExtensionHook (const struct nf_hook_ops *ops,
				    struct sk_buff *skb,
				    const struct net_device *in,
				    const struct net_device *out,
				    int (*okfn)(struct sk_buff *)) {

    struct tcphdr *tcp;
    struct tcphdr _tcph;
    struct mm_struct *mm;
    struct sock *sk;


  sk = skb->sk;
  if (!sk) {
    printk (KERN_INFO "firewall: netfilter called with empty socket!\n");;
    return NF_ACCEPT;
  }

  if (sk->sk_protocol != IPPROTO_TCP) {
    printk (KERN_INFO "firewall: netfilter called with non-TCP-packet.\n");
    return NF_ACCEPT;
  }

    /* get the tcp-header for the packet */
    tcp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(struct tcphdr), &_tcph);
    if (!tcp) {
	printk (KERN_INFO "Could not get tcp-header!\n");
	return NF_ACCEPT;
    }
    if (tcp->syn) {
	struct iphdr *ip;
	
	printk (KERN_INFO "firewall: Starting connection \n");
	ip = ip_hdr (skb);
	if (!ip) {
	    printk (KERN_INFO "firewall: Cannot get IP header!\n!");
	}
	else {
	    printk (KERN_INFO "firewall: Destination address = %u.%u.%u.%u\n", NIPQUAD(ip->daddr));
	}
	printk (KERN_INFO "firewall: destination port = %d\n", htons(tcp->dest)); 
		
	

	if (in_irq() || in_softirq() || !(mm = get_task_mm(current)) || IS_ERR (mm)) {
		printk (KERN_INFO "Not in user context - retry packet\n");
		return NF_ACCEPT;
	}

	
	if (htons (tcp->dest) == 80) {
	    tcp_done (sk); /* terminate connection immediately */
	    return NF_DROP;
	}
    }
    return NF_ACCEPT;	
} // end FirewallExtensionHook

/* the function called to write data into the proc-buffer */
ssize_t kernelRead (struct file *fp,
		 char __user *buffer,  /* the destination buffer */
		 size_t buffer_size,  /* size of buffer */
		 loff_t *offset  /* offset in destination buffer */
	        ) {
  char *pos;    /* the current position in the buffer */
  struct entry_t entry;
  static int finished = 0;
  int retval = 0;  /* number of bytes read; return value for function */
  int i = 0;
  printk (KERN_INFO "procfile_read called with offset of %lld and buffer size %ld\n",  *offset, buffer_size);

  if (finished) {
      printk (KERN_INFO "procfs_read: END\n");
      finished = 0;
      return 0;
  }
  
  pos = buffer;
  while (pos + sizeof (struct entry_t) <= buffer + buffer_size ) {
    entry.field1 = i;  /* create some data */
    entry.field2 = -i; /* create some data */
    copy_to_user (pos, &entry, sizeof (struct entry_t)); /* copy it into user buffer */
    pos += sizeof (struct entry_t); /* increase the counters */
    counter++;
    i ++;
    retval = retval + sizeof (struct entry_t);
  }
  if (counter == BUFFERSIZE) {
      finished = 1;
      counter = 0;
  }
  printk (KERN_INFO "procfile read returned %d byte\n", retval);
  return retval;
} //end KernelRead


/* 
 * The file is opened - we don't really care about
 * that, but it does mean we need to increment the
 * module's reference count. 
 */
int procfs_open(struct inode *inode, struct file *file)
{
    printk (KERN_INFO "kernelRead opened\n");
	try_module_get(THIS_MODULE);
	return 0;
} //end procfs_open

/* 
 * The file is closed - again, interesting only because
 * of the reference count. 
 */
int procfs_close(struct inode *inode, struct file *file)
{
    printk (KERN_INFO "kernelRead closed\n");
	module_put(THIS_MODULE);
	return 0;		/* success */
} //end procfs_close



int init_module(void)
{

  int errno;

  errno = nf_register_hook (&firewallExtension_ops); /* register the hook */
  if (errno) {
    printk (KERN_INFO "Firewall extension could not be registered!\n");
  } 
  else {
    printk(KERN_INFO "Firewall extensions module loaded\n");
  }

  // A non 0 return means init_module failed; module can't be loaded.
  return errno;
}


void cleanup_module(void)
{

    nf_unregister_hook (&firewallExtension_ops); /* restore everything to normal */
    printk(KERN_INFO "Firewall extensions module unloaded\n");
}  
